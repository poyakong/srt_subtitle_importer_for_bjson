<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>SRT字幕导入工具 by 破亚空</title>
		<style>
			/* 沿用原始CSS样式并微调 */
			body {
				font-family: 'Microsoft YaHei', sans-serif;
				margin: 20px;
				background-color: #f5f5f5;
			}
			#main-container {
				display: flex;
				flex-direction: column;
			}
			.container {
				width: 100%;
				max-width: 800px;
				margin: 0 auto;
				background: white;
				padding: 30px;
				border-radius: 10px;
				box-shadow: 0 2px 10px rgba(0,0,0,0.1);
			}
			h1.panel-title {
				text-align: center;
				color: #333;
				margin-bottom: 30px;
			}
			.button-group {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				margin-bottom: 20px;
			}
			button {
				padding: 12px 20px;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				font-size: 14px;
				font-weight: bold;
				transition: all 0.3s ease;
			}
			button:enabled {
				background-color: #007bff;
				color: white;
			}
			button:enabled:hover {
				background-color: #0056b3;
				transform: translateY(-2px);
			}
			button:disabled {
				background-color: #ccc;
				color: #666;
				cursor: not-allowed;
			}
			.file-input {
				display: none;
			}
			/* 状态消息容器样式 - 添加固定高度和过渡 */
			.status-container {
				margin-top: 15px;
				display: flex;
				flex-direction: column;
				gap: 10px;
				min-height: 0; /* 允许容器收缩到内容高度 */
				transition: min-height 0.3s ease-out;
			}

			/* 单个状态消息样式 - 添加动画 */
			.status-message {
				padding: 15px;
				border-radius: 5px;
				font-weight: bold;
				transform: translateY(-20px);
				opacity: 0;
				max-height: 0;
				overflow: hidden;
				transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
				margin-bottom: 0;
			}

			/* 消息显示状态 */
			.status-message.show {
				transform: translateY(0);
				opacity: 1;
				max-height: 200px; /* 足够大的值来容纳内容 */
				margin-bottom: 10px;
			}

			/* 消息隐藏状态 */
			.status-message.hide {
				transform: translateY(-20px);
				opacity: 0;
				max-height: 0;
				margin-bottom: 0;
				padding-top: 0;
				padding-bottom: 0;
			}
			.status-message.success { background-color: #d4edda; color: #155724; }
			.status-message.warning { background-color: #ede6d4; color: #c57600; }
			.status-message.error { background-color: #f8d7da; color: #721c24; }
			.status-message.info { background-color: #d1ecf1; color: #0c5460; }
			.log-area {
				background-color: #f8f9fa;
				border: 1px solid #dee2e6;
				border-radius: 5px;
				padding: 15px;
				margin-top: 20px;
				height: 200px;
				width: calc(100% - 30px); /* Adjust width to account for padding */
				overflow-y: auto;
				font-family: monospace;
				font-size: 12px;
				white-space: pre-wrap;
				line-height: 2;
				resize: vertical;
			}
			/* process-wrapper 和 children-wrapper 已被包含在 template 中 */
			.process-wrapper {
				display: flex;
				flex-direction: column;
				gap: 15px;
				width: 100%;
			}
			.children-wrapper {
				display: flex;
				flex-direction: column;
				gap: 15px;
			}
		</style>
	</head>
	<body>
		<!-- 主应用容器 -->
		<div id="main-container"></div>

		<!-- 统一的应用面板模板 (已更新) -->
		<template id="app-panel-template">
			<div class="process-wrapper">
				<div class="container">
					<h1 class="panel-title">应用标题</h1>
					<div class="button-group"></div>
					<div class="file-input-container"></div>
					<div class="status-container"></div>
					<textarea class="log-area" readonly></textarea>
				</div>
				<div class="children-wrapper"></div>
			</div>
		</template>

		<template id="app-panel-template-log-area">
			<div class="process-wrapper">
				<div class="container">
					<h1 class="panel-title">应用标题</h1>
					<div class="button-group"></div>
					<div class="file-input-container"></div>
					<div class="status-container"></div>
					<div class="log-area" readonly></div>
				</div>
				<div class="children-wrapper"></div>
			</div>
		</template>

		<template id="app-panel-template-text-area">
			<div class="process-wrapper">
				<div class="container">
					<h1 class="panel-title">应用标题</h1>
					<div class="button-group"></div>
					<div class="file-input-container"></div>
					<div class="status-container"></div>
					<textarea class="log-area" readonly></textarea>
				</div>
				<div class="children-wrapper"></div>
			</div>
		</template>

<script>
// =======================================================================
// 共享工具函数
// =======================================================================

// 深拷贝函数 - 用于复制对象
function deepCopy(obj) {
	// 如果可以，使用性能更好的structuredClone
	if (typeof structuredClone === 'function') {
		return structuredClone(obj);	
	}
	return JSON.parse(JSON.stringify(obj));
}

// 版本号比较函数
// 更简洁的版本（不含错误处理）
function compareVersion_greaterEqual(versionString_1 = '', versionString_2 = '') {
  const subversions_1 = versionString_1.split('.').map(Number);
  const subversions_2 = versionString_2.split('.').map(Number);
  const maxLen = Math.max(subversions_1.length, subversions_2.length);
  
  for (let i = 0; i < maxLen; i++) {
    const a = subversions_1[i] || 0;
    const b = subversions_2[i] || 0;
    if (a > b) return true;
    if (a < b) return false;
  }
  return true; // 版本相同时返回true
}

// =======================================================================
// 导入器类 (ImportApp) - 完全独立的 Web Component
// =======================================================================
class ImportApp extends HTMLElement {
	constructor() {
		super(); // 必须调用父类构造函数

		// 在 Web Components 构造函数中不允许使用 appendChild 方法添加模板内容
		// 根据 Web Components 规范，构造函数中不能直接操作 DOM。
		
		// 只保存模板引用，不直接操作DOM
		// this.templateId = 'app-panel-template';
		
		// 初始化状态
		this.state = {
			json_file_name_current: '',
			json_file_name_previous: '',
			json_file_content: null,
			json_file_draftCreatedVersion: 0,
			json_result_content: null,
			srt_file_name_current: '',
			srt_file_name_previous: '',
			srt_file_content: [],
			subtitle_template: { track_template: null, clip_template: null },
			json_existing_m_id_s: null
		};
	}
	
	// 使用 connectedCallback 来执行初始化逻辑
	connectedCallback() {
		// 在这里执行DOM操作
		
		document.getElementById('app-panel-template-log-area') // 如果模板存在，则使用模板内容
		? this.appendChild(document.getElementById('app-panel-template-log-area').content.cloneNode(true)) 
		: this.innerHTML = `
		<div class="process-wrapper">
			<div class="container">
				<h1 class="panel-title">应用标题</h1>
				<div class="button-group"></div>
				<div class="file-input-container"></div>
				<div class="status-container"></div>
				<div class="log-area" readonly></div>
				</div>
			<div class="children-wrapper"></div>
		</div>`;
		
		// 查找并保存常用的UI元素引用
		this.ui = {
			container: this.querySelector('.container'),
			title: this.querySelector('.panel-title'),
			log: this.querySelector('.log-area'),
			buttonGroup: this.querySelector('.button-group'),
			fileInputContainer: this.querySelector('.file-input-container'),
			statusContainer: this.querySelector('.status-container'),
			childrenWrapper: this.querySelector('.children-wrapper')
		};

		// 从元素的attribute获取标题并设置
		if (this.hasAttribute('app-title')) {
			this.ui.title.textContent = this.getAttribute('app-title');
		}

		this.initUI();
		// 初始化日志
		this.log('SRT字幕导入工具');
		this.log('Build(v0.0.0 - v3.5.5): 20250627, Author: poyakong');
		this.log('Build(v3.6.0 - v3.7.18): 20250706, Author: poyakong');
		this.log('✅工具启动成功');
		this.ui.log.innerHTML += `[${(new Date()).toLocaleTimeString()}] ⚠️须知：使用之前，请务必观看教程<a href="https://www.bilibili.com/video/BV1aqK3zEEaG/" target="_blank">BV1aqK3zEEaG</a>\n`;
	}

	initUI() {
		// 以编程方式创建和绑定按钮
		this.ui.buttonGroup.innerHTML = `
			<button class="import-json-btn">导入JSON文件</button>
			<button class="import-srt-btn" disabled>导入SRT字幕</button>
			<button class="generate-btn" disabled>生成字幕到JSON中</button>
			<button class="copy-btn" disabled>复制JSON到剪贴板</button>
			<button class="download-btn" disabled>下载JSON文件</button>
		`;
		
		// 以编程方式创建文件输入
		this.ui.fileInputContainer.innerHTML = `
			<input type="file" class="file-input json-file-input" accept=".json,.bjson">
			<input type="file" class="file-input srt-file-input" accept=".srt">
		`;

		// text-area 不会改变鼠标光标样式
		// this.ui.log.style.cursor = 'default';

		// 绑定事件监听器
		this.querySelector('.import-json-btn').addEventListener('click', () => this.querySelector('.json-file-input').click());
		this.querySelector('.import-srt-btn').addEventListener('click', () => this.querySelector('.srt-file-input').click());
		this.querySelector('.generate-btn').addEventListener('click', () => this.generateSubtitles_main_withVersionChecker());
		this.querySelector('.copy-btn').addEventListener('click', () => this.copyToClipboard());
		this.querySelector('.download-btn').addEventListener('click', () => this.downloadJson());
		
		this.querySelector('.json-file-input').addEventListener('change', (event) => this.jsonContentImport_main_withVersionSelector(event));
		this.querySelector('.srt-file-input').addEventListener('change', (event) => this.srt_content_import(event));
	}
	
	// 移除自身并释放资源
	kill() {
		this.killChildren();
		this.remove(); // 从DOM中移除元素
	}

	// 在children-wrapper内新建component
	createChildren(AppComponentClass, title, initialData = {}) {
		const childComponent = new AppComponentClass();
		childComponent.setAttribute('app-title', title);
		childComponent.initialData = initialData; // 直接通过属性传递数据
		this.ui.childrenWrapper.appendChild(childComponent);
		return childComponent;
	}
	
	// 释放children-wrapper内的所有资源
	killChildren() {
		Array.from(this.ui.childrenWrapper.children).forEach(child => {
			if (typeof child.kill === 'function') {
				child.kill();
			} else {
				child.remove();
			}
		});
		this.ui.childrenWrapper.innerHTML = '';
	}
	
	log(message) {
		const timestamp = (new Date()).toLocaleTimeString();
		this.ui.log.innerHTML += `[${timestamp}] ${message}\n`;
		this.ui.log.scrollTop = this.ui.log.scrollHeight;
		console.log(`[${this.constructor.name}] ${message}`);
	}

	// 在所有三个类中替换 showStatus 方法
	showStatus(message, type = 'info') {
		const statusElement = document.createElement('div');
		statusElement.className = `status-message ${type}`;
		statusElement.textContent = message;
		
		// 添加到容器
		this.ui.statusContainer.prepend(statusElement);
		
		// 使用 requestAnimationFrame 确保元素已被添加到DOM
		requestAnimationFrame(() => {
			statusElement.classList.add('show');
		});
		
		// 5秒后开始隐藏动画
		setTimeout(() => {
			statusElement.classList.add('hide');
			
			// 动画完成后移除元素
			setTimeout(() => {
				if (statusElement.parentNode) {
					statusElement.remove();
				}
			}, 300); // 等待动画完成（300ms）
		}, 6800);
	}
	 
	// 用户风险确认
	user_acknowledge_confirm(){
		if (!confirm("⚠️注意：本操作不可逆\n\n在执行操作前，请务必完整备份了你的项目文件(Bcut Drafts)\n\n⚠️重要：备份文件不允许被保存在Bcut Drafts文件夹内\n\n因为必剪会定时清理Bcut Drafts内所有不相关的文件\n请务必将备份保存在单独的位置，例如硬盘根目录下\n\n⚠️确认：您确认已手动备份文件到安全的位置？")){
			return false;
		}
		if (!confirm("⚠️注意：本工具为第三方工具，不能保证绝对的兼容性\n\n⚠️协议：因为修改JSON文件导致的软件闪退，数据损坏，工程丢失等所有问题，本工具概不负责\n\n⚠️确认：您已了解并确认风险？")){
			return false;
		}
		return true
	}

	jsonContentImport_main_withVersionSelector(event) {
		const file = event.target.files[0];
		if (!file) return;

		this.log(`➡️正在读取工程：${file.name}`);

		const reader = new FileReader();
		reader.onload = (e) => {
			try {
				this.state.json_file_content = JSON.parse(e.target.result);
				
				// 获取版本
				this.state.json_file_draftCreatedVersion = this.state.json_file_content.draftCreatedVersion;

				// 查找"程序定位模板字幕"
				let found = false;

				// 版本检查
				// 查找"程序定位模板字幕" for version_3_6_0_minus
				if (file.name.split('.').pop().toLowerCase() === 'json') {
					if (this.state.json_file_content?.tracks) {
						for (const track of this.state.json_file_content.tracks) {
							if (track?.clips) {
								for (const clip of track.clips) {
									if (clip?.AssetInfo && clip?.AssetInfo.content === "程序定位模板字幕") {
										this.state.subtitle_template.track_template = track;
										this.state.subtitle_template.clip_template = clip;
										// 防止用户设置了voiceid (如果不存在，js会自动创建attachVoiceId，所以这条指令是安全的)
										this.state.subtitle_template.clip_template.attachVoiceId = 0;
										found = true; 
										break;
									}
								}
							}
							if (found) break;
						}
					}
					if (found) {
						this.showStatus('✅JSON文件读取成功！已读取字幕模板', 'success');
						this.log(`✅JSON文件读取成功，模板位置: trackIndex ${this.state.subtitle_template.track_template.trackIndex}`);
					}
				} 
				// 查找"程序定位模板字幕" for version_3_6_0_plus
				else if (file.name.split('.').pop().toLowerCase() === 'bjson') {
					if (this.state.json_file_content?.timelineWidget?.timeline?.captionTracks) {
						for (const captionTrack of this.state.json_file_content.timelineWidget.timeline.captionTracks) {
							if (captionTrack?.captions) {
								for (const caption of captionTrack.captions) {
									if (caption?.captionText === "程序定位模板字幕") {
										this.state.subtitle_template.track_template = captionTrack;
										this.state.subtitle_template.clip_template = caption;
										// v3.6.0 新版本不再拥有voicedid，而是解耦为tts数组储存字幕和音频的对应关系
										found = true;
										break;
									}
								}
							}
							if (found) break;
						}
					}
					if (found) {
						this.showStatus('✅JSON文件读取成功！已读取字幕模板', 'success');
						this.log(`✅JSON文件读取成功，模板位置: index ${this.state.subtitle_template.track_template.index}`);
					}
				} 
				// [error case] 兼容性错误
				else {
					this.showStatus('❌未兼容的版本，本程序也没啥办法呢喵', 'error');
					this.log('❌未兼容的版本，本程序也没啥办法呢喵');
					return;
				}
				if (!found) {
					this.showStatus('程序定位模板字幕 查找失败\n请先在项目中创建一个字幕，且重命名为 ➡️ 程序定位模板字幕', 'error');
					this.log('❌定位字幕 查找失败');
					this.log('请先在项目中创建一个字幕，且重命名为 ➡️ 程序定位模板字幕');
					this.state.json_file_content = null; 
					return;
				}
				
				this.state.json_file_name_current = file.name;
				this.querySelector('.import-srt-btn').disabled = false; // 更新按钮状态

			} catch (error) { 
				this.showStatus('❌JSON文件格式错误：' + error.message, 'error');
				this.log('❌JSON解析错误: ' + error.message);
				console.log(error);
				this.state.json_file_content = null;
			} finally { 
				// 重置 input 元素的 value 属性，兼容同名文件重复读取
				event.target.value = '';
			}
		};
		reader.readAsText(file);
	}
	
	parseTimeToMs(timeStr) {
		const isNegative = timeStr.startsWith('-'), cleanTimeStr = isNegative ? timeStr.substring(1) : timeStr;
		const parts = cleanTimeStr.split(','), timeParts = parts[0].split(':');
		const h = parseInt(timeParts[0])||0, m=parseInt(timeParts[1])||0, s=parseInt(timeParts[2])||0, msVal=parseInt(parts[1])||0;
		return (isNegative ? -1 : 1) * ((h * 3600 + m * 60 + s) * 1000 + msVal);
	}

	srt_content_import(event) {
		const file = event.target.files[0];
		if (!file) return;

		const reader = new FileReader();
		reader.onload = (e) => {
			try {
				// 统一换行符为\n
				const srtText = e.target.result.replace(/\r\n|\r/g, '\n');
				const subtitles = []
				const blocks = srtText.trim().split(/\n\s*\n/);
				let subtitles_import_success_count = 0;

				// [错误检测] 负数时间轴检测
				let hasNegativeTime = false;
				// [错误检测] 字幕顺序错误检测
				let hasOverlappingSubtitles = false;
				let subtitle_end_time_previous = 0;
				const RegExpSubtitle = new RegExp("^(\\d+)\\n(-?\\d{2}:\\d{2}:\\d{2},\\d{3})\\s*-->\\s*(-?\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?:\\n)?$")

				// 使用logBuffer来缓存日志，因为日志记录是最大的性能开销
				let logBuffer = ``;
				const logWithBuffer = (message) => {
					logBuffer += message + '\n';
				};

				logWithBuffer(`➡️正在读取SRT文件：${file.name}`);
				
				for (const [index, block] of blocks.entries()) {
					// 改进后的正则表达式，匹配序号、时间戳和字幕文本，包括末尾换行
					const matches = block.match(RegExpSubtitle);
					if (!matches) {
						logWithBuffer(`❌解析错误:[${index + 1}] 字幕格式错误`);
						continue;
					}
					
					const [, sequenceNumber, startTimeStr, endTimeStr, subtitleText] = matches;
					const startTime = this.parseTimeToMs(startTimeStr);
					const endTime = this.parseTimeToMs(endTimeStr);
					const duration = endTime - startTime;
					let addable = true;
					
					// [错误检测] 负数时间轴检测
					if (startTime < 0 || endTime < 0) {
						logWithBuffer(`❌解析错误:[${index + 1}] 字幕时间轴为负数`);
						hasNegativeTime = true;
						addable = false;
					}
					// [错误检测] 字幕时间长度检测
					if (duration <= 0) {
						logWithBuffer(`❌解析错误:[${index + 1}] 字幕时间长度不正确`);
						addable = false;
					}
					// [错误检测] 字幕重叠错误检测
					if (startTime < subtitle_end_time_previous) {
						logWithBuffer(`⚠️字幕错误:[${index + 1}] 字幕时间轴检测到重叠`);
						hasOverlappingSubtitles = true;
					}
					subtitle_end_time_previous = endTime;
					
					// 将解析结果添加到subtitles数组
					subtitles.push({ 
						text: subtitleText.trim(), 
						start_time: startTime, 
						end_time: endTime, 
						duration: duration, 
						addable: addable
					});
					
					// 20250627 性能瓶颈，在不进行log的情况下只需要1秒就全部解析完了
					// 20250627 而在进行log的情况下，至少需要十几分钟
					// 20250627 使用logWithBuffer()替代this.log()
					// 报告解析结果 
					if (addable) {
						// 20250622 很变态的一行代码，可惜用不上
						// ${subtitleText.length > 8 ? subtitleText.substring(0, 8) + '...' : subtitleText}
						logWithBuffer(`➡️解析成功:[${sequenceNumber}] ${startTimeStr}: \n${subtitleText}`);
						subtitles_import_success_count++;
					} else {
						logWithBuffer(`⚠️解析失败:[${sequenceNumber}] ${startTimeStr}: \n${subtitleText}`);
					}
					
				}

				// 将logBuffer的内容应用
				this.log(logBuffer.trim());
				logBuffer = '';
				
				// 导入结果
				this.showStatus(`✅SRT字幕读取完成！读取了${subtitles_import_success_count}/${blocks.length}个字幕`, 'success');
				this.log(`✅SRT字幕读取完成！读取了${subtitles_import_success_count}/${blocks.length}个字幕`);

				// 尝试修复字幕重叠
				if (hasOverlappingSubtitles) {
					// log
					this.log('⚠️检测到字幕时间轴产生重叠，尝试修复');
					// 对字幕进行排序
					subtitles.sort((a, b) => a.start_time - b.start_time);
					// 重新检查重叠
					hasOverlappingSubtitles = false;
					subtitle_end_time_previous = 0;
					for(const subtitle of subtitles){
						if (subtitle.start_time < subtitle_end_time_previous) {
							hasOverlappingSubtitles = true;
						}
						subtitle_end_time_previous = subtitle.end_time;
					}
					if (hasOverlappingSubtitles) {
						this.log('⚠️字幕时间轴检测到到重叠，且主动尝试修复失败，程序仍会运行，但可能会产生不可预测的错误');
					} else {
						this.log('✅字幕时间轴检测到重叠，但主动尝试修复成功');
					}
				}

				if (hasNegativeTime) {
					this.showStatus('⚠️检测到负数的时间轴，请检查字幕文件', 'warning');
					this.log('⚠️检测到负数的时间轴，请检查字幕文件');
				}
				
				if (blocks.length !== subtitles_import_success_count) {
					this.showStatus(`⚠️SRT文件解析警告：字幕数量不匹配`, 'error');
					this.log(`⚠️SRT文件解析警告：有${blocks.length - subtitles.length}个字幕未能被正确解析`);
				}

				// 保存subtitles到文件
				this.state.srt_file_content = subtitles;

				this.querySelector('.generate-btn').disabled = false; // 更新按钮状态

			} catch (error) { 
				this.showStatus('❌SRT文件解析错误：' + error.message, 'error');
				this.log('❌SRT解析错误: ' + error.message);
				console.log(error);
			} finally { 
				// 重置 input 元素的 value 属性，兼容同名文件重复读取
				event.target.value = '';
			}
		};
		reader.readAsText(file);
	}
	
	generateSubtitles_main_withVersionChecker() {
		// 检查是否重复生成
		if (this.state.json_file_name_current === this.state.json_file_name_previous && confirm("⚠️警告：您已为相同的文件生成过字幕，再次生成会导致字幕复制\n您确定仍然要再次生成吗？") === false) {
			return;
		}

		// 检查版本(理想版本)
		// if (compareVersion_greaterEqual(this.state.json_file_content.draftCreatedVersion, '3.6.0') === false) {
		// 	generateSubtitles_vesion_3_6_0_minus();
		// } else {
		// 	generateSubtitles_vesion_3_6_0_plus();
		// }

		// 检查版本
		const fileSuffix = this.state.json_file_name_current.split('.').pop().toLowerCase();
		if (fileSuffix === 'json') {
			this.generateSubtitles_for_vesion_3_6_0_minus();
		} else if(fileSuffix === 'bjson') {
			this.generateSubtitles_for_vesion_3_6_0_plus();
		} else {
			this.showStatus('❌未知文件格式', 'error');
			this.log('❌未知文件格式');
		}
	}
	
	generateSubtitles_for_vesion_3_6_0_minus() {
		try {
			// 深拷贝模板轨道并添加新的track
			this.state.json_result_content = deepCopy(this.state.json_file_content);
			const newTrack = deepCopy(this.state.subtitle_template.track_template);

			// 清空clips
			newTrack.clips = [];

			// [Edge Case] 当用户错误地使用了MiddleTrack，虽然理论上是不可能的
			if (newTrack.MiddleTrack) {
				newTrack.MiddleTrack = false;
			}
			
			// 获取字幕模板
			const templateClip = this.state.subtitle_template.clip_template;
			// // 获取模板m_id
			// const baseMId = templateClip?.m_id || "1714550534688";
			// // 获取所有现有的m_id
			// const json_existing_m_id_s = new Set();
			// function traverse(obj) { 
			// 	if (typeof obj === 'object' && obj !== null) { 
			// 		if (obj.m_id) {
			// 			json_existing_m_id_s.add(obj.m_id);
			// 		}
			// 		for (const key in obj) {
			// 			traverse(obj[key]);
			// 		}
			// 	} 
			// }
			// traverse(this.state.json_result_content); 
			
			// 为每个SRT字幕生成clip
			// 循环外辅助变量 iterator 用于解决m_id重复问题
			// let iterator = 0;

			// 20250706 删除了m_id的生成，因为必剪会自动修复
			let templateCaption = deepCopy(templateClip);
			delete templateCaption.m_id;
			for (const [index, subtitle] of this.state.srt_file_content.entries()) {
				if (!subtitle.addable) continue;

				const newClip = deepCopy(templateClip);

				// 设置字幕属性
				newClip["30021"] = subtitle.start_time;
				newClip["30012"] = subtitle.duration;
				newClip["AssetInfo"]["content"] = subtitle.text;
				newClip["AssetInfo"]["duration"] = subtitle.duration;
				newClip["inPoint"] = subtitle.start_time;
				newClip["outPoint"] = subtitle.end_time;
				newClip["originTrimOut"] = subtitle.duration;
				newClip["trimOut"] = subtitle.duration;

				// 生成并设置字幕m_id
				// 20250706 删除了m_id的生成，因为必剪会自动修复

				// let newId = baseMId + index + iterator;
				// while (json_existing_m_id_s.has(newId)) {
				// 	iterator++;
				// 	newId++;
				// }
				// newClip["m_id"] = newId;
				// json_existing_m_id_s.add(newClip["m_id"]);

				// 字幕设置完成，添加到轨道中
				newTrack.clips.push(newClip);
			}

			// 将新轨道插入到开头
			this.state.json_result_content.tracks.unshift(newTrack);
			
			// 重新生成所有轨道的 trackIndex
			for (const [index, track] of this.state.json_result_content.tracks.entries()) {
				track.trackIndex = index + 1;
			}
			
			this.showStatus(`✅字幕生成成功！共生成${newTrack.clips.length}个字幕片段`, 'success');
			this.log(`✅字幕生成成功！共生成${newTrack.clips.length}个字幕片段`);
			
			// 启用导出按钮
			this.querySelector('.copy-btn').disabled = false;
			this.querySelector('.download-btn').disabled = false;

			// 记录文件名以备下次检查
			this.state.json_file_name_previous = this.state.json_file_name_current;

			// 保存结果到文件，从而兼容重复生成字幕
			this.state.json_file_content = this.state.json_result_content;

		} catch (error) { 
			this.showStatus('❌生成字幕时出错：' + error.message, 'error'); 
			this.log('❌生成字幕错误: ' + error.message);
			console.log(error);
		}
	}

	generateSubtitles_for_vesion_3_6_0_plus() {
		try{
			// 深拷贝模板轨道并添加新的track
			this.state.json_result_content = deepCopy(this.state.json_file_content);
			const newTrack = deepCopy(this.state.subtitle_template.track_template);

			// 清空captions
			newTrack.captions = [];

			// 获取字幕模板
			const templateClip = this.state.subtitle_template.clip_template;
			// // 获取模板uid
			// const baseUId = templateClip?.uid || "1750739420337";
			// // 获取所有现有的uid
			// const json_existing_uid_s = new Set();
			// function traverse_uid(obj) { 
			// 	if (typeof obj === 'object' && obj !== null) { 
			// 		if (obj.uid) {
			// 			json_existing_uid_s.add(obj.uid);
			// 		}
			// 		for (const key in obj) {
			// 			traverse_uid(obj[key]);
			// 		}
			// 	} 
			// }
			// traverse_uid(this.state.json_result_content);
			// // 获取模板idString，并提前转换为数字从而减少性能消耗
			// // 20250706 Warning，默认值1751816956445142081超出了js的Number.MAX_SAFE_INTEGER，导致精度丢失
			// // 20250706 解决方法：使用BigInt
			// const baseIdString = BigInt(templateClip?.idString || 1751816956445142081);
			// // 获取所有现有的idString
			// const json_existing_idString_s = new Set();
			// function traverse_idString(obj) {
			// 	if (typeof obj === 'object' && obj!== null) {
			// 		if (obj.idString) {
			// 			json_existing_idString_s.add(obj.idString);
			// 		}
			// 		for (const key in obj) {
			// 			traverse_idString(obj[key]);
			// 		}	
			// 	}	
			// }
			// traverse_idString(this.state.json_result_content);

			// 为每个SRT字幕生成clip
			// 循环外辅助变量 iterator 用于解决m_id重复问题
			// let iterator_offset_uid = 0;
			// let iterator_offset_idString = 0;

			// 20250706 删除了uid和idString的生成，因为必剪会自动修复
			let templateCaption = deepCopy(templateClip);
			delete templateCaption["uid"];
			delete templateCaption["idString"];
			for (const [index, subtitle] of this.state.srt_file_content.entries()) {
				if (!subtitle.addable) continue;

				// 20250706 使用templateCaption替代templateClip
				const newClip = deepCopy(templateCaption);

				// 设置字幕属性
				newClip["assetInfo"]["content"] = subtitle.text;
				newClip["assetInfo"]["displayName"] = subtitle.text;
				newClip["captionText"] = subtitle.text;
				newClip["inPoint"] = subtitle.start_time;
				newClip["outPoint"] = subtitle.end_time;

				// // 生成并设置字幕uid
				// 20250706 删除了uid和idString的生成，因为必剪会自动修复
				
				// let new_uid = baseUId + index + iterator_offset_uid;
				// while (json_existing_uid_s.has(new_uid)) {
				// 	iterator_offset_uid++;
				// 	new_uid++;
				// }
				// newClip["uid"] = new_uid;
				// json_existing_uid_s.add(newClip["uid"]);

				// // 生成并设置字幕idString
				// // 20250706 Warning，默认值1751816956445142081超出了js的Number.MAX_SAFE_INTEGER，导致精度丢失
				// // 20250706 解决方法：使用BigInt
				// let newIdString = baseIdString + BigInt(index) + BigInt(iterator_offset_idString);
				// while (json_existing_idString_s.has(String(newIdString))) {
				// 	iterator_offset_idString++;
				// 	newIdString++;	
				// }
				// newClip["idString"] = String(newIdString);
				// json_existing_idString_s.add(newClip["idString"]);

				// 字幕设置完成，添加到轨道中
				newTrack.captions.push(newClip);
			}

			// 设置trackType
			// 3 = 默认字幕
			// 4 = 识别字幕(组合)
			newTrack.trackType = 3;
			// 设置track index
			newTrack.index = this.state.json_result_content.timelineWidget.timeline.captionTracks.length + 1;

			// 将新轨道插入到末尾
			this.state.json_result_content.timelineWidget.timeline.captionTracks.push(newTrack);
			
			// 修复json_result_content.tracking[]？
			// (20250706：目前的必剪能自动修复，不需要进行修改)
			
			this.showStatus(`✅字幕生成成功！共生成${newTrack.captions.length}个字幕片段`, 'success');
			this.log(`✅字幕生成成功！共生成${newTrack.captions.length}个字幕片段`);
			
			// 启用导出按钮
			this.querySelector('.copy-btn').disabled = false;
			this.querySelector('.download-btn').disabled = false;

			// 记录文件名以备下次检查
			this.state.json_file_name_previous = this.state.json_file_name_current;

			// 保存结果到文件，从而兼容重复生成字幕
			this.state.json_file_content = this.state.json_result_content;

		} catch (error) {
			this.showStatus('❌生成字幕时出错：' + error.message, 'error');
			this.log('❌生成字幕错误:'+ error.message);
			console.log(error);
		}
	}


	async copyToClipboard() { 
		if (!this.state.json_result_content) {
			return this.showStatus('❌没有可复制的内容', 'error');
		}
		if (!this.user_acknowledge_confirm()) {
			return this.showStatus('⚠️用户取消操作', 'warning');
		}
		try {
			const jsonString = JSON.stringify(this.state.json_result_content, null, 2);
			await navigator.clipboard.writeText(jsonString);
			this.showStatus('✅JSON已复制到剪贴板', 'success');
			this.log('✅JSON内容已复制到剪贴板');
		} catch (e) {
			this.showStatus('❌复制到剪贴板失败：' + e.message, 'error');
			this.log('❌复制失败: ' + e.message);
			console.log(e);
		}
	}

	downloadJson() { 
		if (!this.state.json_result_content) {
			return this.showStatus('❌没有可下载的内容', 'error');
		}
		if (!this.user_acknowledge_confirm()) {
			return this.showStatus('⚠️用户取消操作', 'warning');
		}
		try {
			const jsonString = JSON.stringify(this.state.json_result_content, null, 2);
			const blob = new Blob([jsonString], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = this.state.json_file_name_current;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			this.showStatus(`➡️JSON文件下载`, 'success');
			this.log(`➡️JSON文件下载`);
		} catch (e) {
			this.showStatus('❌下载JSON文件失败：' + e.message, 'error');
			this.log('❌下载JSON文件失败: ' + e.message);
			console.log(e);
		}
	}
}

// =======================================================================
// 导出器类 (ExportApp) - 完全独立的 Web Component
// =======================================================================
class ExportApp extends HTMLElement {
	constructor() {
		super();
		
		this.state = {
			json_file_name_current: '',
			json_file_content: null,
			subtitles_with_track_index: [],
		};
	}
	
	connectedCallback() {

		// 使用默认模板或自定义模板
		document.getElementById('app-panel-template-log-area') // 如果模板存在，则使用模板内容
		? this.appendChild(document.getElementById('app-panel-template-log-area').content.cloneNode(true)) 
		: this.innerHTML = `
		<div class="process-wrapper">
			<div class="container">
				<h1 class="panel-title">应用标题</h1>
				<div class="button-group"></div>
				<div class="file-input-container"></div>
				<div class="status-container"></div>
				<textarea class="log-area" readonly></textarea>
				</div>
			<div class="children-wrapper"></div>
		</div>`;

		this.ui = {
			container: this.querySelector('.container'),
			title: this.querySelector('.panel-title'),
			log: this.querySelector('.log-area'),
			buttonGroup: this.querySelector('.button-group'),
			fileInputContainer: this.querySelector('.file-input-container'),
			statusContainer: this.querySelector('.status-container'),
			childrenWrapper: this.querySelector('.children-wrapper')
		};

		if (this.hasAttribute('app-title')) {
			this.ui.title.textContent = this.getAttribute('app-title');
		}
		this.initUI();
		this.log('SRT字幕扫描工具');
		this.log('Build(v0.0.0 - v3.5.4): 20250622, Author: poyakong');
		this.log('Build(v3.6.0 - v3.7.14): 20250706, Author: poyakong');
		this.log('✅工具启动成功');
	}

	initUI() {
		this.ui.buttonGroup.innerHTML = `<button class="import-json-btn">导入JSON文件</button>`;
		this.ui.fileInputContainer.innerHTML = `<input type="file" class="file-input json-file-input" accept=".json,.bjson">`;

		// text-area 不会改变鼠标光标样式
		// this.ui.log.style.cursor = 'default';
		
		this.querySelector('.import-json-btn').addEventListener('click', () => this.querySelector('.json-file-input').click());
		this.querySelector('.json-file-input').addEventListener('change', (event) => this.handleFile(event));
	}

	kill() {
		this.killChildren();
		this.remove();
	}

	createChildren(AppComponentClass, title, initialData = {}) {
		const childComponent = new AppComponentClass();
		childComponent.setAttribute('app-title', title);
		childComponent.initialData = initialData;
		this.ui.childrenWrapper.appendChild(childComponent);
		return childComponent;
	}

	killChildren() {
		Array.from(this.ui.childrenWrapper.children).forEach(child => {
			if (typeof child.kill === 'function') {
				child.kill();
			} else {
				child.remove();
			}
		});
		this.ui.childrenWrapper.innerHTML = '';
	}

	log(message) {
		const timestamp = (new Date()).toLocaleTimeString();
		this.ui.log.innerHTML += `[${timestamp}] ${message}\n`;
		this.ui.log.scrollTop = this.ui.log.scrollHeight;
		console.log(`[${this.constructor.name}] ${message}`);
	}

	// 在所有三个类中替换 showStatus 方法
	showStatus(message, type = 'info') {
		const statusElement = document.createElement('div');
		statusElement.className = `status-message ${type}`;
		statusElement.textContent = message;
		
		// 添加到容器
		this.ui.statusContainer.prepend(statusElement);
		
		// 使用 requestAnimationFrame 确保元素已被添加到DOM
		requestAnimationFrame(() => {
			statusElement.classList.add('show');
		});
		
		// 5秒后开始隐藏动画
		setTimeout(() => {
			statusElement.classList.add('hide');
			
			// 动画完成后移除元素
			setTimeout(() => {
				if (statusElement.parentNode) {
					statusElement.remove();
				}
			}, 300); // 等待动画完成（300ms）
		}, 6800);
	}

	handleFile(event) {
		this.killChildren(); 
		this.state.subtitles_with_track_index = []; // 重置状态
		const file = event.target.files[0]; 
		if (!file) return;

		this.log(`➡️正在读取文件: ${file.name}`);
		const reader = new FileReader();
		reader.onload = (e) => {
			try {
				this.state.json_file_name_current = file.name;
				this.state.json_file_content = JSON.parse(e.target.result);
				if (!this.state.json_file_content.draftCreatedVersion) {
					this.log('❌JSON文件错误，检查不到文件元数据，不受支持的文件');
					this.showStatus('❌JSON文件错误，检查不到文件元数据', 'error'); 
					return;
				}
				this.log(`✅JSON文件读取成功，文件版本：${this.state.json_file_content.draftCreatedVersion}`);
				this.showStatus('✅JSON文件读取成功!', 'success');
				// 版本检查
				// v0.0.0 - v3.5.4
				if (file.name.split('.').pop().toLowerCase() === 'json') {
					this.extractSubtitleTracks_from_version_3_6_0_minus(this.state.json_file_content);
				}
				// v3.6.0 - v3.7.14 
				else if (file.name.split('.').pop().toLowerCase() === 'bjson') {
					this.extractSubtitleTracks_from_version_3_6_0_plus(this.state.json_file_content);
				} 
				// version error
				else {
					this.showStatus('❌未兼容的版本，本程序也没啥办法呢喵', 'error');
					this.log('❌未兼容的版本，本程序也没啥办法呢喵');
				}
			} catch (error) { 
				this.showStatus('❌文件解析失败!', 'error'); 
				this.log('❌JSON解析错误: ' + error.message);
				console.log(error);
			} finally { 
				event.target.value = ''; 
			}
		};
		reader.readAsText(file, 'utf-8');
	}
	
	extractSubtitleTracks_from_version_3_6_0_minus(jsonContent) {
		// 完备检查，防止因 track.clips 不存在或不是数组而引发forEach报错
		if (!jsonContent?.tracks || !Array.isArray(jsonContent.tracks)) {
			this.log('❌未在JSON中找到有效的 "tracks" 数据');
			return;
		}

		jsonContent.tracks.forEach((track, index) => {
			const subtitlesInTrack = [];
			if (track.clips && Array.isArray(track.clips)) {
				track.clips.forEach(clip => {
					// 检查可选链操作结果，若为 undefined 或 null 则跳过当前循环
					const featureId = clip?.["10105"];
					if (featureId === undefined || featureId === null) return;
					const text = clip?.AssetInfo?.content;
					if (text === undefined || text === null) return;
					const startTime = clip?.inPoint;
					if (startTime === undefined || startTime === null) return;
					const endTime = clip?.outPoint;
					if (endTime === undefined || endTime === null) return;

					// 没有错误，则将字幕添加到数组中
					subtitlesInTrack.push({ text: text, startTime: startTime, endTime: endTime });
				});
			}
			if (subtitlesInTrack.length > 0) {
				subtitlesInTrack.sort((a, b) => a.startTime - b.startTime);
				this.state.subtitles_with_track_index.push({
					trackIndex: track?.trackIndex || (index + 1), 
					subtitles: subtitlesInTrack
				});
			}
		});

		if (this.state.subtitles_with_track_index.length > 0) {
			this.showStatus('✅成功提取了字幕轨道数据。', 'success');
			this.log(`✅成功提取了 ${this.state.subtitles_with_track_index.length} 条字幕轨道的数据。`);
			this.generateSrtFromGroups(this.state.subtitles_with_track_index);
		} else { 
			this.showStatus('⚠️未找到可导出的字幕。', 'warning');
			this.log('⚠️未在文件中找到可识别的字幕片段 (特征ID: 10105)');
		}
	}

	extractSubtitleTracks_from_version_3_6_0_plus(jsonContent) {
		// 完备检查，防止因 track.clips 不存在或不是数组而引发forEach报错
		if (!jsonContent?.timelineWidget?.timeline?.captionTracks || !Array.isArray(jsonContent.timelineWidget.timeline.captionTracks)) {
			this.log('❌未在JSON中找到有效的 "tracks" 数据');
			return;
		}
		jsonContent.timelineWidget.timeline.captionTracks.forEach((track, index) => {
			const subtitlesInTrack = [];
			if (track.captions && Array.isArray(track.captions)) {
				track.captions.forEach(clip => {
					// 检查可选链操作结果，若为 undefined 或 null 则跳过当前循环
					const text = clip?.captionText;
					if (text === undefined || text === null) return;
					const startTime = clip?.inPoint;
					if (startTime === undefined || startTime === null) return;
					const endTime = clip?.outPoint;
					if (endTime === undefined || endTime === null) return;

					// 没有错误，则将字幕添加到数组中
					subtitlesInTrack.push({ text: text, startTime: startTime, endTime: endTime });
				});
			}
			if (subtitlesInTrack.length > 0) {
				subtitlesInTrack.sort((a, b) => a.startTime - b.startTime);
				this.state.subtitles_with_track_index.push({
					trackIndex: track?.trackIndex || (index + 1),
					subtitles: subtitlesInTrack
				});	
			}
		});
		if (this.state.subtitles_with_track_index.length > 0) {
			this.showStatus('✅成功提取了字幕轨道数据。', 'success');
			this.log(`✅成功提取了 ${this.state.subtitles_with_track_index.length} 条字幕轨道的数据。`);
			this.generateSrtFromGroups(this.state.subtitles_with_track_index);
		} else { 
			this.showStatus('⚠️未找到可导出的字幕。', 'warning');
			this.log('⚠️未在文件中找到可识别的字幕片段 (function version_3_6_0_plus)');
		}
	}
	
	generateSrtFromGroups(subtitlesWithTrackIndex) {
		subtitlesWithTrackIndex.forEach(trackData => {
			let subtitleContent = '', subtitleLastEndTime = -1;
			trackData.subtitles.forEach((subtitle, index) => {
				if (subtitleLastEndTime > subtitle.startTime) {
					this.log(`⚠️警告：字幕重叠错误 - 轨道 "${trackData.trackIndex}" 的第 ${index + 1} 条字幕与上一条存在时间重叠`);
					this.log(`⚠️[${index + 1} ${subtitle.text}]`);
				}
				subtitleContent += `${index + 1}\n${this.msToSrtTime(subtitle.startTime)} --> ${this.msToSrtTime(subtitle.endTime)}\n${subtitle.text}\n\n`;
				subtitleLastEndTime = subtitle.endTime;
			});
			if (subtitleContent) {
				const now = new Date();
				const title = `扫描结果: 轨道 ${trackData.trackIndex}`;
				// 不理想，文件名太长了
				// fileName: `${this.state.json_file_name_current}.track-${subtitles_with_track_index.trackIndex}.srt`, 
				const fileName = `SRT ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}-${String(now.getMinutes()).padStart(2,'0')}-${String(now.getSeconds()).padStart(2,'0')}.track-${trackData.trackIndex}.srt`;
				const data = { content: subtitleContent.trim(), fileName: fileName };

				// 使用 createChildren 方法创建 DownloadApp 实例
				this.createChildren(DownloadApp, title, data);
			}
		});
	}

	msToSrtTime(ms) { 
		if (ms < 0) ms = 0;
		let date = new Date(ms);
		let h = String(date.getUTCHours()).padStart(2, '0'), m = String(date.getUTCMinutes()).padStart(2, '0'), s = String(date.getUTCSeconds()).padStart(2, '0'), msVal = String(date.getUTCMilliseconds()).padStart(3, '0');
		return `${h}:${m}:${s},${msVal}`;
	}
}

// =======================================================================
// 下载应用类 (DownloadApp) - 完全独立的 Web Component
// =======================================================================
class DownloadApp extends HTMLElement {
	constructor() {
		super();
		
		// initialData 将由父组件在创建时设置
		this.fileName = 'download.txt';
		this.content = '';
	}

	connectedCallback() {
		// 使用默认模板或自定义模板
		document.getElementById('app-panel-template') // 如果模板存在，则使用模板内容
		? this.appendChild(document.getElementById('app-panel-template').content.cloneNode(true)) 
		: this.innerHTML = `
		<div class="process-wrapper">
			<div class="container">
				<h1 class="panel-title">应用标题</h1>
				<div class="button-group"></div>
				<div class="file-input-container"></div>
				<div class="status-container"></div>
				<textarea class="log-area" readonly></textarea>
				</div>
			<div class="children-wrapper"></div>
		</div>`;

		this.ui = {
			container: this.querySelector('.container'),
			title: this.querySelector('.panel-title'),
			log: this.querySelector('.log-area'),
			buttonGroup: this.querySelector('.button-group'),
			statusContainer: this.querySelector('.status-container'),
			childrenWrapper: this.querySelector('.children-wrapper')
		};

		if (this.hasAttribute('app-title')) {
			this.ui.title.textContent = this.getAttribute('app-title');
		}
		// 从 initialData 获取数据
		if (this.initialData) {
			this.fileName = this.initialData.fileName || this.fileName;
			this.content = this.initialData.content || this.content;
		}
		this.initUI();
	}
	
	initUI() {
		this.ui.log.value = this.content;
		this.ui.log.readOnly = false; // 用户可以编辑
		
		this.ui.buttonGroup.innerHTML = `
			<button class="copy-btn">复制SRT到剪贴板</button>
			<button class="download-btn">下载SRT文件</button>
		`;
		
		this.querySelector('.copy-btn').addEventListener('click', () => this.copyToClipboard());
		this.querySelector('.download-btn').addEventListener('click', () => this.download());

		// 下载组件不需要创建子组件，所以隐藏或移除children-wrapper
		if (this.ui.childrenWrapper) {
			this.ui.childrenWrapper.style.display = 'none';
		}
	}

	kill() {
		this.remove();
	}

	// 在所有三个类中替换 showStatus 方法
	showStatus(message, type = 'info') {
		const statusElement = document.createElement('div');
		statusElement.className = `status-message ${type}`;
		statusElement.textContent = message;
		
		// 添加到容器
		this.ui.statusContainer.prepend(statusElement);
		
		// 使用 requestAnimationFrame 确保元素已被添加到DOM
		requestAnimationFrame(() => {
			statusElement.classList.add('show');
		});
		
		// 5秒后开始隐藏动画
		setTimeout(() => {
			statusElement.classList.add('hide');
			
			// 动画完成后移除元素
			setTimeout(() => {
				if (statusElement.parentNode) {
					statusElement.remove();
				}
			}, 300); // 等待动画完成（300ms）
		}, 6800);
	}
	
	async copyToClipboard() {
		try {
			// 从textarea获取最新内容，以防用户编辑过
			await navigator.clipboard.writeText(this.ui.log.value);
			this.showStatus('✅SRT内容已复制到剪贴板', 'success');
			this.log('✅SRT内容已复制到剪贴板');
		} catch (error) {
			this.showStatus('❌复制失败: ' + error.message, 'error');
			this.log('❌复制失败:'+ error.message);
			console.log(error);
		}
	}

	download() {
		try {
			const blob = new Blob([this.ui.log.value], { type: 'text/plain;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = this.fileName.replace(/[^a-z0-9_-\s.]/gi, '').trim() || 'subtitle.srt';
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		} catch (error) {
			this.showStatus('❌下载失败: ' + error.message, 'error');
			this.log('❌下载失败:'+ error.message);
			console.log(error);
		}
	}
}

// =======================================================================
// 主程序入口
// =======================================================================
window.onload = () => {
	// 1. 定义所有自定义元素
	customElements.define('import-app', ImportApp);
	customElements.define('export-app', ExportApp);
	customElements.define('download-app', DownloadApp);

	// 2. 获取主容器
	const mainContainer = document.getElementById('main-container');

	// 3. 创建并添加初始的应用实例
	const importer = document.createElement('import-app');
	importer.setAttribute('app-title', 'SRT字幕导入工具 for 必剪JSON');
	mainContainer.appendChild(importer);
	
	const exporter = document.createElement('export-app');
	exporter.setAttribute('app-title', '字幕扫描与导出 for 必剪JSON');
	mainContainer.appendChild(exporter);
	
	console.log("Web Components Initialized.");
};
</script>
</body>
</html>
